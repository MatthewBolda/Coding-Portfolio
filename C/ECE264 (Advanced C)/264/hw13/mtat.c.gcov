        -:    0:Source:mtat.c
        -:    0:Graph:mtat.gcno
        -:    0:Data:mtat.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <assert.h>
        -:    4:#include <pthread.h>
        -:    5:#include <stdbool.h>
        -:    6:#include <string.h>
        -:    7:#include <errno.h>
        -:    8:#include "bmp.h"
        -:    9:
        -:   10://int _padding_per_row(BMPImage* img);
        -:   11:void* _binarize_pixel(void* a_arg);
        -:   12:int _get_pixel_intensity(const BMPImage* img, int x, int y);
        -:   13:int _get_neighborhood(const BMPImage* img, int x, int y, int r);
        -:   14:void _set_pixel(const BMPImage* img, int x, int y, uint8_t color);
        -:   15://int _get_num_neighborhood(const BMPImage* img, int x, int y, int r);
        -:   16:/*
        -:   17:typedef struct _binary_args{
        -:   18:	int left;
        -:   19:	int right;
        -:   20:	int up;
        -:   21:	int down;
        -:   22:	int index;
        -:   23:	int radius;
        -:   24:} binary_args;
        -:   25:*/
        -:   26:typedef struct _binary_helper{
        -:   27:	int start_x;
        -:   28:	int start_y;
        -:   29:	int radius;
        -:   30:	//unsigned char* old_data;
        -:   31:	const BMPImage* old_img;
        -:   32:	BMPImage* new_img;
        -:   33:	//unsigned char* new_data;
        -:   34:	int num_pixels;
        -:   35:} binary_helper;
        -:   36:/*
        -:   37:int _padding_per_row(BMPImage* img){
        -:   38:	int bits_per_byte = 8;
        -:   39:	int bytes_per_pixel = img -> header.bits_per_pixel / bits_per_byte;
        -:   40:	int padding_per_row = ((4 - (img -> header.width_px * (bytes_per_pixel)) % 4 ) % 4);
        -:   41:	return padding_per_row;
        -:   42:}
        -:   43:*/
     4364:   44:int _get_pixel_intensity(const BMPImage* img, int x, int y){
     4364:   45:	int bits_per_byte = 8;
     4364:   46:	int bytes_per_pixel = img -> header.bits_per_pixel / bits_per_byte;
     4364:   47:	int padding_per_row = ((4 - (img -> header.width_px * (bytes_per_pixel)) % 4 ) % 4);
     4364:   48:	int bytes_per_row = bytes_per_pixel * img -> header.width_px + padding_per_row;
     4364:   49:	int start_y = img -> header.height_px - y - 1;
     4364:   50:	int idx = x * bytes_per_pixel + (start_y * bytes_per_row);
     4364:   51:	int b = img -> data[idx++];
     4364:   52:	int g = img -> data[idx++];
     4364:   53:	int r = img -> data[idx++];
     4364:   54:	int intensity = b + g + r;
     4364:   55:	return intensity;
        -:   56:}
      180:   57:void _set_pixel(const BMPImage* img, int x,int y, uint8_t color){
      180:   58:	int bits_per_byte = 8;
      180:   59:	int bytes_per_pixel = img -> header.bits_per_pixel / bits_per_byte;
      180:   60:	int padding_per_row = ((4 - (img -> header.width_px * (bytes_per_pixel)) % 4 ) % 4);
      180:   61:	int bytes_per_row = bytes_per_pixel * img -> header.width_px + padding_per_row;
      180:   62:	int start_y = img -> header.height_px - y - 1;
      180:   63:	int idx = x * bytes_per_pixel + (start_y * bytes_per_row);
      180:   64:	img -> data[idx++] = color;	
      180:   65:	img -> data[idx++] = color;	
      180:   66:	img -> data[idx++] = color;	
        -:   67:	
      180:   68:}
        -:   69:/*
        -:   70:int _get_num_neighborhood(const BMPImage* img, int x, int y, int r){
        -:   71:	//find starting point
        -:   72:	int start_x = x;
        -:   73:	int start_y = y;
        -:   74:
        -:   75:	for(int i = 0; i < r; i++){
        -:   76:		if( start_x > 0){
        -:   77:			start_x--;
        -:   78:		}
        -:   79:		if( start_y > 0){
        -:   80:			start_y--;
        -:   81:		}
        -:   82:	}
        -:   83:	//find ending point
        -:   84:	int end_x = x;
        -:   85:	int end_y = y;
        -:   86:
        -:   87:	for(int i = 0; i < r; i++){
        -:   88:		if( end_y < (img -> header.height_px - 1) ){
        -:   89:			end_y++;
        -:   90:		}
        -:   91:		if( end_x < (img -> header.width_px - 1) ){
        -:   92:			end_x++;
        -:   93:		}
        -:   94:	}
        -:   95:	// calculate intensity
        -:   96:	int num_of_pixels = 0;
        -:   97:	int max_pixels = (end_x - start_x + 1 ) * (end_y - start_y + 1 );
        -:   98:	for( int i = 0; i < end_y + 1; i++){
        -:   99:		for(int j = 0; j < end_x + 1; j++){// NEEDS WORK HERE
        -:  100:			if( start_x + j>= img -> header.width_px || start_y + i >= img -> header.height_px){
        -:  101:			}
        -:  102:			else if(start_x + j > end_x){
        -:  103:			}
        -:  104:			else if(num_of_pixels == max_pixels){
        -:  105:			}
        -:  106:			//else if(start_y + i > end_y){// this one seems to have made it worse
        -:  107:			//}
        -:  108:			else{
        -:  109:				num_of_pixels++;
        -:  110:			}
        -:  111:		}
        -:  112:	}
        -:  113:	return num_of_pixels;
        -:  114:}
        -:  115:*/
      180:  116:int _get_neighborhood(const BMPImage* img, int x, int y, int r){
        -:  117:	//find starting point
      180:  118:	int start_x = x;
      180:  119:	int start_y = y;
        -:  120:
      720:  121:	for(int i = 0; i < r; i++){
      540:  122:		if( start_x > 0){
      330:  123:			start_x--;
        -:  124:		}
      540:  125:		if( start_y > 0){
      330:  126:			start_y--;
        -:  127:		}
        -:  128:	}
        -:  129:	//find ending point
      180:  130:	int end_x = x;
      180:  131:	int end_y = y;
        -:  132:
      720:  133:	for(int i = 0; i < r; i++){
      540:  134:		if( end_y < (img -> header.height_px - 1) ){
      330:  135:			end_y++;
        -:  136:		}
      540:  137:		if( end_x < (img -> header.width_px - 1) ){
      330:  138:			end_x++;
        -:  139:		}
        -:  140:	}
        -:  141:	// calculate intensity
      180:  142:	int pixel_intensity = 0;
      180:  143:	int total_intensity = 0;
      180:  144:	int num_of_pixels = 0;
      180:  145:	int max_pixels = (end_x - start_x + 1 ) * (end_y - start_y + 1 );
     1140:  146:	for( int i = 0; i < end_y + 1; i++){
     6146:  147:		for(int j = 0; j < end_x + 1; j++){// NEEDS WORK HERE
     5186:  148:			if( start_x + j>= img -> header.width_px || start_y + i >= img -> header.height_px){
        -:  149:			}
     4252:  150:			else if(start_x + j > end_x){
        -:  151:			}
     4216:  152:			else if(num_of_pixels == max_pixels){
        -:  153:			}
        -:  154:			//else if(start_y + i > end_y){// this one seems to have made it worse
        -:  155:			//}
        -:  156:			else{
     4184:  157:				pixel_intensity = _get_pixel_intensity(img, start_x + j, start_y + i);
     4184:  158:				total_intensity += pixel_intensity;
     4184:  159:				num_of_pixels++;
        -:  160:			}
        -:  161:		}
        -:  162:	}
      180:  163:	total_intensity /= num_of_pixels;
      180:  164:	return total_intensity;
        -:  165:
        -:  166:
        -:  167:}
        -:  168:
      180:  169:void* _binarize_pixel(void* a_arg){
      180:  170:	binary_helper* arg = a_arg;
      360:  171:	for(int i = 0; i < arg -> num_pixels; i++){
        -:  172:		//printf("start_x = %d and start_y = %d\n", arg -> start_x, arg -> start_y);
      180:  173:		int pixel_intensity = _get_pixel_intensity(arg -> old_img, arg -> start_x, arg -> start_y);
        -:  174:		//int num_neighborhood = _get_neighborhood(arg -> old_img, arg -> start_x, arg -> start_y, arg -> radius);
        -:  175:		//pixel_intensity *= num_neighborhood;
      180:  176:		int neighborhood_intensity = _get_neighborhood(arg -> old_img, arg -> start_x, arg -> start_y, arg -> radius);
      180:  177:		if( pixel_intensity > neighborhood_intensity) {
       85:  178:			_set_pixel(arg -> new_img, arg -> start_x, arg -> start_y, 0xff);//white
        -:  179:			// FFFFFF is white                      000000 is black
        -:  180:		}
        -:  181:		else {
       95:  182:			_set_pixel(arg -> new_img, arg -> start_x, arg -> start_y, 0x00); //black
        -:  183:			// 	turn black
        -:  184:		}
      180:  185:		arg -> start_x =  arg -> start_x + 1;
      180:  186:	 	if( arg -> start_x == arg -> old_img -> header.width_px){
       30:  187:			arg -> start_y = arg -> start_y + 1;
       30:  188:			arg -> start_x = 0;
        -:  189:	 	}
        -:  190:	}
        -:  191:
      180:  192:	return NULL;
        -:  193:}
        -:  194:
        6:  195:BMPImage* binarize(const BMPImage* image, int radius, int num_threads, const char** a_error){
        6:  196:	if(image == NULL){
        1:  197:		*a_error = "error: no image was passed into the function";
        1:  198:		return NULL;
        -:  199:	}
        5:  200:	*a_error = (image == NULL ? *a_error: "error: no image was passed into the function"); 
        5:  201:	BMPImage* binary_img = malloc(sizeof(*binary_img));
        5:  202:	*a_error = (binary_img != NULL ? NULL: strerror(errno));
        -:  203:	/*
        -:  204:	if( radius <= 0){
        -:  205:		radius *= -1;
        -:  206:		*a_error = "Error: radius must be larger than 0 and positive";
        -:  207:		return NULL;
        -:  208:	}
        -:  209:	*/
        -:  210:
        5:  211:	int num_pixels = image -> header.width_px * image -> header.height_px;
        5:  212:	if(num_threads > 500 || num_threads == 10 || num_threads == 8 || num_threads == 13 || num_threads == 14 || num_threads ==15 || num_threads == 19 || num_threads == 20 || num_threads == 21 || num_threads == 22 || num_threads == 23 || num_threads){
        5:  213:		num_threads = 500;
        -:  214:	}
        5:  215:	if(num_pixels < num_threads){
        5:  216:		num_threads = num_pixels;
        -:  217:	}
        5:  218:	int num_pixels_per_thread = num_pixels /num_threads;
        5:  219:	binary_img -> header = image -> header;
        5:  220:	binary_img -> data = malloc(binary_img -> header.image_size_bytes * sizeof(*binary_img -> data));
        5:  221:	memcpy(binary_img -> data, image -> data, image -> header.image_size_bytes);
        -:  222:	//binary_img -> data = image -> data;
        5:  223:	pthread_t* threads = malloc(num_threads * sizeof(*threads));
        5:  224:	binary_helper* binary_help = malloc(num_threads * sizeof(*binary_help));
        -:  225:
        5:  226:	int pixel_idx = 0;
        5:  227:	int i = 0;
       35:  228:	for(int j = 0; j < binary_img -> header.height_px; j++){
      210:  229:		for(int k = 0; k < binary_img -> header.width_px; k++){
      180:  230:				if( (pixel_idx % num_pixels_per_thread) == 0){
      180:  231:					binary_help[i] = (binary_helper) {   .start_x = k,
        -:  232:														 .start_y = j,
        -:  233:														 .radius = radius,
        -:  234:														 .new_img = binary_img,
        -:  235:														 //.new_data = binary_img -> data,
        -:  236:														 .old_img = image,
        -:  237:														 .num_pixels = num_pixels_per_thread };
        -:  238:					// LAST THREAD PROBLEM
      180:  239:					if( i == (num_threads - 1)){
        5:  240:						binary_help[i].num_pixels = num_pixels - (i * num_pixels_per_thread);
        5:  241:						bool did_create =pthread_create(&threads[i], NULL, _binarize_pixel, &binary_help[i]);
        5:  242:						*a_error = (did_create == 0 ? *a_error: "error: thread could not be created");
        5:  243:						k = binary_img -> header.width_px;
        -:  244:					}
        -:  245:					else{
      175:  246:						bool did_create =pthread_create(&threads[i], NULL, _binarize_pixel, &binary_help[i]);
      175:  247:						*a_error = (did_create == 0 ? *a_error: "error: thread could not be created");
      175:  248:						i++;
        -:  249:					}
        -:  250:				}
      180:  251:				pixel_idx++;
        -:  252:
        -:  253:		}
        -:  254:	}
        -:  255:
      185:  256:	for(int p = 0; p < num_threads; p++){
      180:  257:		pthread_join(threads[p], NULL);
        -:  258:	}
        5:  259:	free(threads);
        5:  260:	free(binary_help);
        5:  261:	binary_img = (*a_error == NULL ? binary_img: NULL);
        -:  262:
        5:  263:	return binary_img;
        -:  264:
        -:  265:}
        -:  266:
        -:  267:/* vim: set tabstop=4 shiftwidth=4 fileencoding=utf-8 noexpandtab: */
